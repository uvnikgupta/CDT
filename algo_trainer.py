import os, yaml, datetime, shutil, math, time
import numpy as np
import pandas as pd
import networkx as nx
from networkx.drawing.nx_agraph import graphviz_layout
import matplotlib.pyplot as plt
import openpyxl
from openpyxl.drawing.image import Image
from io import BytesIO
from PIL import Image as PILImage
from sklearn.preprocessing import StandardScaler
from cdt.causality.graph import (GS, GIES, PC, SAM, IAMB, Inter_IAMB, 
                                 Fast_IAMB, MMPC, LiNGAM, CAM, CCDr)
from cdt.metrics import precision_recall, SID, SHD
from scmodels import SCM
from scm.dynamic_scm import DynamicSCM
import cdt_algo_eval_common_methods as cdt_cm

plt.switch_backend('agg')

class AlgoTrainer():
    plots_sheet_name = "plots"
    config_sheet_name = "configs"
    metrics = {
            "aupr":'round(precision_recall(orig_dag, algo_dag)[0], 2)', 
            "sid":'int(SID(orig_dag, algo_dag))',
            "shd":'int(SHD(orig_dag, algo_dag))',
            "rt":'round(time.time() - start, 2)'
            }
    
    def __init__(self, num_iterations, sample_sizes, 
                 plots_file, cdt_algos_file, data_folder):
        self.num_iterations = num_iterations
        self.sample_sizes = sample_sizes
        self.plots_file = plots_file
        self.cdt_algos_file = cdt_algos_file
        self.data_folder = data_folder
        self.__set_xl_row_num()

    def __set_xl_row_num(self):
        row = 1
        if os.path.exists(self.plots_file):
            workbook = openpyxl.load_workbook(self.plots_file)
            sheet = workbook[self.plots_sheet_name]
            while sheet.cell(row=row, column=2).value is not None:
                row +=1
            workbook.close()
        self.row = row
        
    def get_algo_metrics(self, algo_name, orig_dag, algo_dag, start):
        retval ={}
        if algo_dag is not None:
            for metric, formula in self.metrics.items():
                if "sam" in algo_name.lower() and "sid" in metric.lower():
                    # Calculating SID for DAGs generated by SAM does not finish
                    # in reasonable time. Hence setting this metric to inf for SAM
                    retval[metric] = np.inf
                else:
                    retval[metric] = eval(formula)
        else:
            for metric, formula in self.metrics.items():
                retval[metric] = 0
        return retval

    def get_algos_for_training(self, conf):
        with open(self.cdt_algos_file) as file:
            models = yaml.safe_load(file)

        algos = []
        for algo_meta_data in models:
            if "type" in algo_meta_data:
                if "type" in conf and algo_meta_data["type"] == conf["type"]:
                    # add type specifc algos
                    algos.append(algo_meta_data)
                elif "type" not in conf and algo_meta_data["type"] == 1:
                    # if conf is of mixed type add continuous alogs
                    algos.append(algo_meta_data)
            else: # add common algos
                algos.append(algo_meta_data)
        return algos
    
    def get_timeout_value(self, conf, num_samples):
        if isinstance(conf["nodes"], list):
            num_nodes = sum(conf["nodes"])
        else:
            num_nodes = conf["nodes"]
        
        timeout = int(math.exp(int(math.log(num_nodes)) + 
                            int(math.log(math.sqrt((num_samples))))))
        return timeout

    def get_node_colors(self, dag):
        nodes = dag.nodes()
        colors = ['#F9E79F','#A3E4D7','#D7BDE2','#A9CCE3','#DAF7A6',
                  '#EBDEF0','#EDBB99','#3498DB','#EC7063','#E5E8E8',]
        node_colors = []
        prev_level = ""
        index = -1
        for node in nodes:
            cur_level = node[0]
            if cur_level != prev_level:
                prev_level = cur_level
                index += 1
            if index > len(colors) - 1:
                index = 0
            node_colors.append(colors[index])
        return node_colors

    def check_num_rows_in_xl_and_move_it(self, xl_file):
        if self.row > 10:
            prefix = datetime.datetime.now().strftime("%d%H%M%S")
            new_file_path = f"{os.path.splitext(xl_file)[0]}_{prefix}.xlsx"
            shutil.move(xl_file, new_file_path)
            self.row = 1
            cdt_cm.log_progress(f"The file '{xl_file}' has been renamed \
to '{new_file_path}' due to exceeding the maximum size.")
            
    def get_xl_workbook_for_plots(self, xl_file_path):
        workbook = None
        if os.path.exists(xl_file_path):
            self.check_num_rows_in_xl_and_move_it(xl_file_path)

        try:
            workbook = openpyxl.load_workbook(xl_file_path)
        except:
            workbook = openpyxl.Workbook()
            plots_sheet = workbook.active
            plots_sheet.title = self.plots_sheet_name
            configs_sheet = workbook.create_sheet()
            configs_sheet.title = self.config_sheet_name
        return workbook

    def get_score_text(self, score_data):
        text = ""
        for metric, values in score_data.items():
            if metric != "dag":
                text += f"{metric}:{values}\n"
        return text

    def scale_data(self, data):
        columns = data.columns
        scaler = StandardScaler()
        data = scaler.fit_transform(data)
        data = pd.DataFrame(data=data, columns=columns)
        return data

    

    

    